---
title: MySQL(六) MySQL索引
date: 2021-08-17 15:02:25
tags:
    - 数据库
    - MySQL
---

# 前言


这篇文章演示环境为：MySQL5.7。

主要内容为基于[MySQL5.7官方文档](https://dev.mysql.com/doc/refman/5.7/en/)的学习，对MySQL索引相关内容的整理及自己的理解。

如有错误或疑问，欢迎讨论！

<!-- more -->

数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。

假设我们需要从500万行数据里面检索一条数据，那么只能依次遍历这张表的全部数据（循环调用存储引擎的读取下一行数据的接口），直到找到这条数据。

所以我们需要某样东西来提高我们的查询效率 **索引**

当我们有了索引之后，只需要在索引里面去检索这条数据就行了，因为索引它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，
就可以拿到数据了。

# 索引类型

在InnoDB中，索引共有三种，普通索引、唯一索引（主键索引是一种特殊的唯一索引）、全文索引。

- 普通索引（Normal）: 也叫非唯一索引，是最普通的索引，没有任何的限制。
- 唯一索引（Unique）：唯一索引要求键值不能重复。另外需要注意的是，主键索引是一种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空。主键索引用 primay key创建。
- 全文索引（Fulltext）：针对比较大的数据，比如我们存放的是消息内容，有几KB的数据的这种情况， 如果要解决like查询效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比 如 char、varchar、text。

**注意：**

每个InnoDB表中都有一个被称为**聚集索引**的特殊索引，用于存储行数据

聚集索引的目的是为了在查询、插入等数据库操作时获得最佳的性能

- 当表中定义有主键时，InnoDB将定义为主键的字段作为聚集索引
- 当表中未定义有主键时，InnoDB则使用第一个唯一索引，并将这个唯一索引的字段定义为not null来作为聚集索引
- 当表中未定义有主键，且也未有合适的唯一索引时，InnoDB生成以*GEN_CLUST_INDEX*命名，包含行ID值的列来作为隐藏的聚集索引

> 行ID是一个6字节的字段，会随着插入新行而增加。
> 
> 按行ID排序，在物理上就是按插入顺序排列。

# 索引的存储模型

因为索引是一种特殊的专门用来**快速检索**的**数据结构**

那么假想一下：存在着一组数据，需要我们人为去检索它，我们会用什么方法？

## 存储模型推导

**二分法**

也就是二分查找，我们需要先将这组数据排序，每一次从中间选择数据比较，来判断下一次取左半区，还是右半区继续查找，
这样，每一次，我们都能把候选数据缩小了一半。

所以如果通过二分法去检索这组数据，我们用到的索引就是一个**有序数组**形式的数据结构

但是有序数组在更新的时候存在一个问题，可能要挪动大量的数据（改变 index），所以只适合存储静态的数据。

所以为了支持频繁的修改，比如插入数据，我们需要采用**链表**，一种**支持二分查找的链表**。

**二叉查找树（BST Binary Search Tree）**

![Binary Search Tree](https://avriesl.github.io/images/mysql/bst.png)

二叉查找树的特点是什么？
左子树所有的节点都小于父节点，右子树所有的节点都大于父节点。投影到平面以后，就是一个有序的线性表。

二叉查找树既能够实现快速查找，又能够实现快速插入。

但是二叉查找树有一个问题：就是它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。

![Bad Binary Search Tree](https://avriesl.github.io/images/mysql/bad-bst.png)

如果我们插入的数据刚好是有序的，5、7、12、14、17、 25。 这个时候二叉查找树变成了什么样了呢？
它会变成链表（我们把这种树叫做“斜树”），这种情况下不能达到加快检索速度的目的，和顺序查
找效率是没有区别的。

因为左右子树深度差太大，这棵树的左子树根本没有节点——也就是它不够平衡。 所以我们需要一种**左右子树深度相差不大的树**。

**平衡二叉树（AVL Tree）**

![AVL Tree](https://avriesl.github.io/images/mysql/AVL-Tree.png)

平衡二叉树的定义：左右子树深度差绝对值不能超过 1。

这个时候我们再按顺序插入 1、2、3、4、5、6，一定是这样，不会变成一棵“斜树”。

所以为了保持平衡，AVL树在插入和更新数据的时候执行了一系列的计算和调整的操作。

现在平衡的问题解决了，那么AVL树可以被作为索引使用了么？

首先，在平衡二叉树中，一个节点它的大小是一个固定的单位

它应该存储三块的内容：

1. 索引的键值。比如我们在 id 上面创建了一个索引，我在用 where id =1 的条件查询的时候 就会找到索引里面的 id 的这个键值。
2. 数据的磁盘地址，因为索引的作用就是去查找数据的存放的地址。
3. 左子节点和右子节点的引用，用于找到下一个节点。比如大于 26 的时候，走右边，到下一个树的节点，继续判断。

如果是这样存储数据的话，对于人为操作数据的我们没有什么问题了。

如果作为数据库索引使用，我们来看一下会有什么问题。

首先，对于InnoDB来说，索引的数据是放在硬盘上的。
如果使用AVL树作为索引的话，访问一个节点就要跟磁盘之间发生一次I/O。
InnoDB操作磁盘的最小的单位是一页（或者叫一个磁盘块），大小是16K(16384 字节)。

那么，一个树的节点就是16K的大小。
如果我们一个节点只存一个键值+数据+引用，例如整形的字段，可能只用了十几个或者几十个字节，
它远远达不到16384字节的容量，所以访问一个树节点，进行一次IO的时候，浪费了大量的空间。

同时每个节点存储的数据太少，从索引中找到我们需要的数据，就要访问更多的节点，意味着 跟磁盘交互次数就会过多，消耗的时间也越多。

所以在AVL树的基础上，我们需要它每个节点存储更多数据，不仅仅包含左右子节点的引用、不仅仅包含单个数据的磁盘地址。
所以我们需要一种**多叉，或者叫做多路**的树。

**多路平衡查找树（B Tree）**

Balanced Tree，也就是多路平衡查找树，通常叫做B Tree

它的特点是：分叉数（路数）永远比关键字数多 1。比如我们画的这棵树，每个节点存储两个关键字，那么就会有三个指针指向三个子节点。

![B Tree](https://avriesl.github.io/images/mysql/B-Tree.png)

这样我们就得到了一个具有**快速检索、树形结构、平衡、多路**等特性的树，一种适合作为数据库索引的数据结构。

**加强版多路平衡查找树（B+ Tree）**

在InnoDB中，索引的数据结构是B+ Tree

通过我们前面的分析，B Tree的效率已经很高了，为什么MySQL还要对B Tree进行改良呢？

![B+ Tree](https://avriesl.github.io/images/mysql/B+Tree.png)

上图为InnoDB里面的B+树的存储结构，B+树具有两个特点：
1. 它的关键字的数量是跟路数相等的；
2. B+Tree的根节点和枝节点中都不会存储数据，只有叶子节点才存储数据。

为什么InnoDB要做这样的改良？
1. B+Tree是B Tree的变种，B Tree能解决的问题，它都能解决。B Tree解决的两大问题是什么？（每个节点存储更多关键字；路数更多）
2. 扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵树，才能拿到所有的数据）
3. B+Tree的磁盘读写能力相对于B Tree来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
4. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
5. 效率更加稳定（B+Tree永远是在叶子节点拿到数据，所以 IO 次数是稳定的，恒定为树的深度）

## 其他的存储模型

### Hash索引

![Hash Table](https://avriesl.github.io/images/mysql/Hash-Table.png)

哈希索引有什么特点呢？

1. 它的时间复杂度是 O(1)，查询速度比较快。但是哈希索引里面的数据不是按顺序存储的， 所以不能用于排序。
2. 我们在查询数据的时候要根据键值计算哈希码，所以它只能支持等值查询（= IN），不支 持范围查询（> < >= <= between and）。
3. 如果字段重复值很多的时候，会出现大量的哈希冲突（采用拉链法解决），效率会降低。需要注意的是，在 InnoDB 中，不能显示地创建一个哈希索引（所谓的支持哈希索引指的是
Adaptive Hash Index）

注：memory与NDB存储引擎可以使用Hash索引。

# 索引的落地形式

通过[MySQL(一) MySQL内部架构及各组件功能](https://avriesl.github.io/2021/08/16/MySQL-%E4%B8%80-MySQL%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%90%84%E7%BB%84%E4%BB%B6%E5%8A%9F%E8%83%BD/)
中MySQL的物理架构我们知道，不同的存储引擎，数据文件格式是不一样。

可通过以下命令查看数据文件的存储目录：

```sql
mysql> show variables like 'datadir';
+---------------+-----------------+
| Variable_name | Value           |
+---------------+-----------------+
| datadir       | /var/lib/mysql/ |
+---------------+-----------------+
```

在数据库中使用相同字段分别使用InnoDB、MyISAM、MEMORY三种存储引擎创建了三个表user_innodb、user_myisam、user_memory，
并插入相同的数据。然后进入数据文件目录中，查看一下他的数据文件格式分别是什么？

![data dir](https://avriesl.github.io/images/mysql/datadir.png)

其中：

- user_innodb表有两个数据文件，分别是user_innodb.frm与user_innodb.ibd；
- user_myisam表有三个数据文件，分别是user_myisam.MYD、user_myisam.MYI、user_myisam.frm；
- user_memory表有一个数据文件，是user_memory.frm；

三种存储引擎均生成了.frm文件，.frm是MySQL里面表结构定义的文件，建表的时候选用任何 一个存储引擎都会生成。

## MyISAM落地形式

除去.frm文件外，MyISAM表还生成了两个数据文件

1. .MYD文件：MY代表MyISAM存储引擎，D代表Data，是MyISAM的数据文件，存放数据记录，user_myisam.MYD文件代表该文件存储了user_myisam表中的所有数据。
2. .MYI文件：MY代表MyISAM存储引擎，I代表Index，是MyISAM的索引文件，存放索引记录，user_myisam.MYI文件代表该文件存储了user_myisam表中的所有索引。

也就是说在MyISAM存储引擎里面，索引和数据是两个独立的文件。

MyISAM的B+Tree索引里面，叶子节点存储的是数据文件对应的磁盘地址。所以从索引文件.MYI中找到键值后，会到数据文件.MYD中获取相应的数据记录。
Hash索引同理。

## MEMORY落地形式

MEMORY表落地文件仅有.frm即表结构定义文件

原因是MEMORY存储引擎的特殊性，MEMORY存储引擎的数据是存储在内存中的，并未存入磁盘，所以不存在数据或索引文件。

## InnoDB落地形式

除去.frm文件外，InnoDB表仅生成了.ibd文件

那么.ibd文件存储的是数据还是索引呢？

这就涉及了InnoDB的一个特点：
**数据即索引，索引即数据**

.ibd文件中即存储了数据也存储了索引，在InnoDB的B+Tree索引中，它以主键（**聚集索引**）为索引来构成B+Tree的数据结构，其叶子节点存储了数据。

但这产生了一个问题，InnoDB表可能存在多个索引，但数据只有一份，那么除**聚集索引**外的其他索引的叶子节点存储的是什么？

在InnoDB中，索引可以分为两种**聚集索引**和**二级索引（也叫做辅助索引）**，
**聚集索引**我们在上文索引的类型中有详细讲解过，而除**聚集索引**以外的所有索引我们统一叫做**二级索引**。

由于数据是存储在**聚集索引**B+ Tree的叶子节点上的，且为了节省数据占用空间，所以数据也只有**聚集索引**上那一份，
所以**二级索引**的叶子节点中存储的是**聚集索引**的键值。

举个例子：

user_innodb表结构与数据如下，其中id为主键（聚集索引），name字段为普通索引（二级索引）
```sql
mysql> select * from user_innodb;
+----+-------+
| id | name  |
+----+-------+
|  1 | laim  |
|  2 | laim2 |
|  3 | laim3 |
+----+-------+
```

那么，在user_innodb.ibd文件中，存在两棵B+ Tree，
1. 由聚集索引构成的B+ Tree，其中非叶子节点存储键值id以及子节点引用，叶子节点存储具体数据
2. 有二级索引构成的B+ Tree，其中非叶子节点存储键值name以及子节点引用，叶子节点存储name对应的id的值

当使用where name="laim"作为条件查询时，name字段上存在索引，所以先检索二级索引的B+ Tree，找到name="laim"对应的叶子节点，
其叶子节点存储了*id 1*，再通过id=1到聚集索引的B+ Tree中查询具体数据。

所以使用聚集索引会比使用二级索引检索速度相对快一点，因为它少扫描了一棵B+ Tree。

> 在上述表结构情况下，
> 执行select id, name from user_innodb where name = 'laim'语句时，
> 底层其实仅扫描了一棵B+ Tree，因为要查询的字段，id和name，在检索完第一课B+ Tree时就已经获取到了，
> 这种情况下就不会再去检索聚集索引的B+ Tree。
> 
> 如果user_innodb表中还存在sex字段，而当前实现的语句为select id, name, sex from user_innodb where name = 'laim'语句时，
> 底层在扫描完第一颗树后，仅获取到了id、name两个字段，这种情况才需要再通过id去查询聚集索引树，检索出全部数据。
> 这种现象也叫做**回表查询**。
> 
> 在我们书写sql语句时，要尽量避免回表查询

# 索引的使用

以下是我对索引使用的一个总结，仅供参考：

1. 建立索引的字段，不允许有空
2. 建立索引的字段，数据长度不易过长
3. 建立索引的字段，最好选择常用且重复度低的
4. 常用的，且具有关联性的字段，建议使用联合索引，这样可避免回表
5. 仅查询需要的字段，减少查询时的盎余字段，避免回表
6. 索引数量不易过多，浪费空间且会导致数据更新变慢
7. 频繁更新的字段，不建议创建索引

索引失效的场景：

1. 索引列上使用函数（replace\SUBSTR\CONCAT\sum count avg）、表达式，可能会导致索引失效
2. 字符串不加引号，出现隐式转换，可能会导致索引失效
3. like条件中前面带%，可能会导致索引失效（检索字符时，也遵循最左匹配原则）
4. 负向查询，例如NOT LIKE、!= （<>）和 NOT IN，某些情况下会导致索引失效
